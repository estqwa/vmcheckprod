package quizmanager

import (
	"context"
	"errors"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/yourusername/trivia-api/internal/domain/entity"
	"github.com/yourusername/trivia-api/internal/domain/repository"
)

// scheduledQuiz хранит cancel функцию с уникальным токеном для безопасного cleanup
type scheduledQuiz struct {
	cancel context.CancelFunc
	token  uint64
}

// Scheduler отвечает за планирование и отмену викторин
type Scheduler struct {
	// Настройки
	config *Config

	// Зависимости
	deps *Dependencies

	// Внутреннее состояние (защищено mutex)
	mu           sync.Mutex
	quizCancels  map[uint]scheduledQuiz
	tokenCounter uint64

	// Канал для сигнализации о запуске викторины
	quizStartCh chan uint
}

// NewScheduler создает новый планировщик викторин
func NewScheduler(config *Config, deps *Dependencies) *Scheduler {
	return &Scheduler{
		config:      config,
		deps:        deps,
		quizCancels: make(map[uint]scheduledQuiz),
		quizStartCh: make(chan uint, 10),
	}
}

// GetQuizStartChannel возвращает канал для уведомлений о запуске викторин
func (s *Scheduler) GetQuizStartChannel() <-chan uint {
	return s.quizStartCh
}

// ScheduleQuiz планирует запуск викторины в заданное время
func (s *Scheduler) ScheduleQuiz(ctx context.Context, quizID uint, scheduledTime time.Time) error {
	// Сразу проверяем, что время в будущем
	if scheduledTime.Before(time.Now()) {
		return fmt.Errorf("ошибка: scheduled time is in the past")
	}

	// Получаем викторину
	quiz, err := s.deps.QuizRepo.GetWithQuestions(quizID)
	if err != nil {
		return err
	}

	// Strict mode: проверяем что суммарно вопросов хватит на MaxQuestionsPerQuiz
	quizQCount := len(quiz.Questions)
	if quizQCount < s.config.MaxQuestionsPerQuiz {
		ok, err := s.hasEnoughQuestions(quizQCount)
		if err != nil {
			return fmt.Errorf("question availability check failed: %w", err)
		}
		if !ok {
			return fmt.Errorf("недостаточно вопросов: в викторине %d, в пуле не хватает до %d",
				quizQCount, s.config.MaxQuestionsPerQuiz)
		}
		if quizQCount == 0 {
			log.Printf("[Scheduler] Quiz #%d: no preset questions, using pool", quizID)
		}
	}

	// Точечное обновление scheduled_time и status (не перетираем другие поля)
	if err := s.deps.QuizRepo.UpdateScheduleInfo(quizID, scheduledTime, entity.QuizStatusScheduled); err != nil {
		return err
	}
	quiz.ScheduledTime = scheduledTime
	quiz.Status = entity.QuizStatusScheduled

	// Атомарное планирование под mutex
	s.mu.Lock()
	// Отменяем старый таймер, если есть
	if old, exists := s.quizCancels[quizID]; exists {
		old.cancel()
		delete(s.quizCancels, quizID)
		log.Printf("[Scheduler] Quiz #%d: old timer cancelled", quizID)
	}

	// Создаем новый контекст для этой викторины с возможностью отмены
	quizCtx, quizCancel := context.WithCancel(ctx)

	// Генерируем уникальный токен (под mutex, atomic не нужен)
	s.tokenCounter++
	newToken := s.tokenCounter

	// Сохраняем scheduledQuiz с токеном
	s.quizCancels[quizID] = scheduledQuiz{cancel: quizCancel, token: newToken}

	// Warning при >4 одновременно запланированных
	activeCount := len(s.quizCancels)
	if activeCount > 4 {
		log.Printf("[Scheduler] WARNING: Запланировано %d викторин одновременно (рекомендуемый лимит: 4)", activeCount)
	}
	s.mu.Unlock()

	// Запускаем последовательность событий в фоновом режиме
	go s.runQuizSequence(quizCtx, quiz, newToken)

	log.Printf("[Scheduler] Викторина #%d запланирована на %v", quizID, scheduledTime)
	return nil
}

// CancelQuiz отменяет запланированную викторину
func (s *Scheduler) CancelQuiz(quizID uint) error {
	// Получаем викторину
	quiz, err := s.deps.QuizRepo.GetByID(quizID)
	if err != nil {
		return err
	}

	// Проверяем, что викторина запланирована
	if !quiz.IsScheduled() {
		return fmt.Errorf("quiz is not in scheduled state")
	}

	// Отменяем таймер под mutex
	s.mu.Lock()
	sq, exists := s.quizCancels[quizID]
	if !exists {
		s.mu.Unlock()
		log.Printf("[Scheduler] Предупреждение: функция отмены для викторины #%d не найдена", quizID)
		// Продолжаем, чтобы обновить статус в БД
	} else {
		sq.cancel()
		delete(s.quizCancels, quizID)
		s.mu.Unlock()
		log.Printf("[Scheduler] Таймеры для викторины #%d отменены", quizID)
	}

	// Обновляем статус в БД
	if err := s.deps.QuizRepo.UpdateStatus(quizID, entity.QuizStatusCancelled); err != nil {
		return err
	}

	// Отправляем уведомление пользователям
	if s.deps.WSManager != nil {
		cancelEvent := map[string]interface{}{
			"type": "quiz:cancelled",
			"data": map[string]interface{}{
				"quiz_id": quizID,
				"reason":  "cancelled_by_admin",
				"message": "Quiz has been cancelled",
			},
		}
		if err := s.deps.WSManager.BroadcastEventToQuiz(quizID, cancelEvent); err != nil {
			log.Printf("[Scheduler] WARNING: не удалось отправить quiz:cancelled для викторины #%d: %v", quizID, err)
		}
	}

	log.Printf("[Scheduler] Викторина #%d отменена", quizID)
	return nil
}

// hasEnoughQuestions проверяет, хватит ли вопросов (quiz-specific + пул) на MaxQuestionsPerQuiz
func (s *Scheduler) hasEnoughQuestions(quizQuestionCount int) (bool, error) {
	if s.deps.QuestionRepo == nil {
		return false, nil
	}
	needed := s.config.MaxQuestionsPerQuiz - quizQuestionCount
	if needed <= 0 {
		return true, nil // Quiz-specific вопросов достаточно
	}
	poolAvailable, err := s.deps.QuestionRepo.CountAvailablePool()
	if err != nil {
		return false, fmt.Errorf("pool count failed: %w", err)
	}
	log.Printf("[Scheduler] Pool check: needed=%d, available=%d", needed, poolAvailable)

	// Soft warning: учитываем потенциальный спрос от уже запланированных квизов
	s.mu.Lock()
	scheduledCount := len(s.quizCancels)
	s.mu.Unlock()
	if scheduledCount > 0 {
		potentialDemand := scheduledCount * s.config.MaxQuestionsPerQuiz
		if int(poolAvailable) < potentialDemand+needed {
			log.Printf("[Scheduler] WARNING: Пул (%d) может быть недостаточен для %d запланированных + %d новых вопросов",
				poolAvailable, potentialDemand, needed)
		}
	}

	return int(poolAvailable) >= needed, nil
}

// refreshQuiz загружает актуальные данные викторины из БД (без вопросов)
func (s *Scheduler) refreshQuiz(quiz *entity.Quiz) *entity.Quiz {
	fresh, err := s.deps.QuizRepo.GetByID(quiz.ID)
	if err != nil {
		log.Printf("[Scheduler] WARNING: Не удалось обновить данные викторины #%d: %v. Используем кешированные.", quiz.ID, err)
		return quiz
	}
	return fresh
}

// runQuizSequence выполняет последовательность событий викторины
func (s *Scheduler) runQuizSequence(ctx context.Context, quiz *entity.Quiz, myToken uint64) {
	defer func() {
		// Атомарное удаление: только если это наш токен
		s.mu.Lock()
		if sq, exists := s.quizCancels[quiz.ID]; exists && sq.token == myToken {
			delete(s.quizCancels, quiz.ID)
		}
		s.mu.Unlock()
	}()

	// Таймауты для каждого события.
	// Важно: перед каждым этапом обновляем quiz из БД, чтобы учитывать актуальный scheduled_time.
	// Это защищает от рассинхрона времени в рамках длинной sequence.
	quiz = s.refreshQuiz(quiz)
	announcementTime := quiz.ScheduledTime.Add(-time.Duration(s.config.AnnouncementMinutes) * time.Minute)

	// Планируем анонс, если время еще не наступило
	if announcementTime.After(time.Now()) {
		timeToAnnouncement := time.Until(announcementTime)
		log.Printf("[Scheduler] Викторина #%d: планирую анонс через %v", quiz.ID, timeToAnnouncement)

		select {
		case <-time.After(timeToAnnouncement):
			// Отправляем анонс
			s.triggerAnnouncement(ctx, quiz)
		case <-ctx.Done():
			log.Printf("[Scheduler] Викторина #%d: анонс отменен", quiz.ID)
			return
		}
	}

	// Планируем открытие зала ожидания, если время еще не наступило
	quiz = s.refreshQuiz(quiz)
	waitingRoomTime := quiz.ScheduledTime.Add(-time.Duration(s.config.WaitingRoomMinutes) * time.Minute)
	if waitingRoomTime.After(time.Now()) {
		timeToWaitingRoom := time.Until(waitingRoomTime)
		log.Printf("[Scheduler] Викторина #%d: планирую открытие зала ожидания через %v", quiz.ID, timeToWaitingRoom)

		select {
		case <-time.After(timeToWaitingRoom):
			// Открываем зал ожидания
			s.triggerWaitingRoom(ctx, quiz)
		case <-ctx.Done():
			log.Printf("[Scheduler] Викторина #%d: открытие зала ожидания отменено", quiz.ID)
			return
		}
	}

	// Планируем обратный отсчет, если время еще не наступило
	quiz = s.refreshQuiz(quiz)
	countdownTime := quiz.ScheduledTime.Add(-time.Duration(s.config.CountdownSeconds) * time.Second)
	startTime := quiz.ScheduledTime
	if countdownTime.After(time.Now()) {
		timeToCountdown := time.Until(countdownTime)
		log.Printf("[Scheduler] Викторина #%d: планирую обратный отсчет через %v", quiz.ID, timeToCountdown)

		select {
		case <-time.After(timeToCountdown):
			// Запускаем обратный отсчет
			s.triggerCountdown(ctx, quiz)
		case <-ctx.Done():
			log.Printf("[Scheduler] Викторина #%d: обратный отсчет отменен", quiz.ID)
			return
		}
	} else if time.Until(startTime) > 0 {
		// Если время для отсчета уже прошло, но викторина еще не должна начаться,
		// ждем точного времени начала
		timeToStart := time.Until(startTime)
		log.Printf("[Scheduler] Викторина #%d: слишком поздно для отсчета, ожидание начала (%v)", quiz.ID, timeToStart)

		select {
		case <-time.After(timeToStart):
			// Сигнализируем о начале викторины
			s.triggerQuizStart(ctx, quiz)
		case <-ctx.Done():
			log.Printf("[Scheduler] Викторина #%d: запуск отменен", quiz.ID)
			return
		}
	} else {
		// Если время уже прошло, сразу запускаем викторину
		log.Printf("[Scheduler] Викторина #%d: время начала уже прошло, запускаю немедленно", quiz.ID)
		s.triggerQuizStart(ctx, quiz)
	}
}

// triggerAnnouncement отправляет анонс о предстоящей викторине
func (s *Scheduler) triggerAnnouncement(ctx context.Context, quiz *entity.Quiz) {
	quiz = s.refreshQuiz(quiz)
	log.Printf("[Scheduler] Отправка анонса для викторины #%d", quiz.ID)

	// Рассчитываем оставшееся время до старта викторины
	timeToStart := time.Until(quiz.ScheduledTime)

	announcementData := map[string]interface{}{
		"quiz_id":          quiz.ID,
		"title":            quiz.Title,
		"description":      quiz.Description,
		"scheduled_time":   quiz.ScheduledTime,
		"question_count":   quiz.QuestionCount,
		"minutes_to_start": int(timeToStart.Minutes()),
	}

	// Используем новую сигнатуру
	fullEvent := map[string]interface{}{ // Или websocket.Event
		"type": "quiz:announcement",
		"data": announcementData,
	}
	s.deps.WSManager.BroadcastEventToQuiz(quiz.ID, fullEvent)
}

// triggerWaitingRoom открывает зал ожидания для викторины
func (s *Scheduler) triggerWaitingRoom(ctx context.Context, quiz *entity.Quiz) {
	quiz = s.refreshQuiz(quiz)
	log.Printf("[Scheduler] Открытие зала ожидания для викторины #%d", quiz.ID)

	// Рассчитываем оставшееся время до старта викторины
	timeToStart := time.Until(quiz.ScheduledTime)

	waitingRoomData := map[string]interface{}{
		"quiz_id":           quiz.ID,
		"title":             quiz.Title,
		"description":       quiz.Description,
		"scheduled_time":    quiz.ScheduledTime,
		"question_count":    quiz.QuestionCount,
		"starts_in_seconds": int(timeToStart.Seconds()),
	}

	// Используем новую сигнатуру
	fullEvent := map[string]interface{}{ // Или websocket.Event
		"type": "quiz:waiting_room",
		"data": waitingRoomData,
	}
	s.deps.WSManager.BroadcastEventToQuiz(quiz.ID, fullEvent)
}

// triggerCountdown запускает обратный отсчет для викторины
func (s *Scheduler) triggerCountdown(ctx context.Context, quiz *entity.Quiz) {
	quiz = s.refreshQuiz(quiz)
	startTime := quiz.ScheduledTime
	log.Printf("[Scheduler] Запуск обратного отсчета для викторины #%d", quiz.ID)

	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			remainingTime := time.Until(startTime)
			secondsLeft := int(remainingTime.Seconds())

			if secondsLeft <= 0 {
				log.Printf("[Scheduler] Обратный отсчет завершен для викторины #%d, запуск викторины", quiz.ID)
				s.triggerQuizStart(ctx, quiz)
				return
			}

			log.Printf("[Scheduler] Обратный отсчет викторины #%d: %d сек.", quiz.ID, secondsLeft)
			countdownData := map[string]interface{}{
				"quiz_id":      quiz.ID,
				"seconds_left": secondsLeft,
			}
			fullEvent := map[string]interface{}{
				"type": "quiz:countdown",
				"data": countdownData,
			}
			s.deps.WSManager.BroadcastEventToQuiz(quiz.ID, fullEvent)

		case <-ctx.Done():
			log.Printf("[Scheduler] Обратный отсчет для викторины #%d отменен", quiz.ID)
			return
		}
	}
}

// triggerQuizStart запускает викторину
func (s *Scheduler) triggerQuizStart(ctx context.Context, quiz *entity.Quiz) {
	// Перечитываем актуальные данные (title, description, prize могли измениться)
	quiz = s.refreshQuiz(quiz)
	log.Printf("[Scheduler] Запуск викторины #%d", quiz.ID)

	// Атомарный старт: scheduled → in_progress.
	// Partial unique index гарантирует max 1 in_progress одновременно.
	if err := s.deps.QuizRepo.AtomicStartQuiz(quiz.ID); err != nil {
		switch {
		case errors.Is(err, repository.ErrAnotherQuizInProgress):
			log.Printf("[Scheduler] WARNING: Викторина #%d отменена: уже есть другая активная викторина (%v)", quiz.ID, err)

			// Конфликт активных стартов: переводим этот запуск в cancelled и уведомляем клиентов лобби.
			if cancelErr := s.deps.QuizRepo.UpdateStatus(quiz.ID, entity.QuizStatusCancelled); cancelErr != nil {
				log.Printf("[Scheduler] WARNING: Не удалось обновить статус викторины #%d в cancelled: %v", quiz.ID, cancelErr)
			}
			if s.deps.WSManager != nil {
				cancelEvent := map[string]interface{}{
					"type": "quiz:cancelled",
					"data": map[string]interface{}{
						"quiz_id": quiz.ID,
						"reason":  "another_quiz_active",
						"details": err.Error(),
					},
				}
				s.deps.WSManager.BroadcastEventToQuiz(quiz.ID, cancelEvent)
			}
		case errors.Is(err, repository.ErrQuizNotScheduled):
			// Идемпотентный/повторный старт: ничего не отменяем.
			log.Printf("[Scheduler] INFO: Пропуск старта викторины #%d: не в статусе scheduled (%v)", quiz.ID, err)
		default:
			// Системная ошибка БД/соединения: не меняем статус, чтобы можно было восстановить запуск.
			log.Printf("[Scheduler] ERROR: Не удалось стартовать викторину #%d из-за системной ошибки: %v", quiz.ID, err)
		}
		return
	}

	// 2. Фиксируем QuestionCount (точечно, без перезаписи остальных полей)
	quiz.QuestionCount = s.config.MaxQuestionsPerQuiz
	if err := s.deps.QuizRepo.UpdateQuestionCount(quiz.ID, quiz.QuestionCount); err != nil {
		log.Printf("[Scheduler] WARNING: Не удалось записать QuestionCount=%d для викторины #%d: %v",
			quiz.QuestionCount, quiz.ID, err)
	} else {
		log.Printf("[Scheduler] Викторина #%d: QuestionCount=%d зафиксирован", quiz.ID, quiz.QuestionCount)
	} // Отправляем событие запуска (теперь question_count корректен)
	startEvent := map[string]interface{}{
		"quiz_id":        quiz.ID,
		"title":          quiz.Title,
		"question_count": quiz.QuestionCount,
	}
	fullEvent := map[string]interface{}{
		"type": "quiz:start",
		"data": startEvent,
	}
	s.deps.WSManager.BroadcastEventToQuiz(quiz.ID, fullEvent)
	log.Printf("[Scheduler] Уведомление о запуске викторины #%d отправлено", quiz.ID)

	// Сигнализируем QuizManager о запуске викторины
	// Используем неблокирующую отправку на случай, если канал переполнен
	select {
	case s.quizStartCh <- quiz.ID:
		log.Printf("[Scheduler] Сигнал о запуске викторины #%d отправлен в QuizManager", quiz.ID)
	default:
		log.Printf("[Scheduler] Предупреждение: не удалось отправить сигнал о запуске викторины #%d в QuizManager (канал переполнен?)", quiz.ID)
	}
}
